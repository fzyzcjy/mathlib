/-
Copyright (c) 2022 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/
import order.upper_lower
import topology.separation
import logic.equiv.defs
import topology.algebra.constructions
import topology.order.lattice

/-!
# Lower topology

This file introduces the lower topology on a preorder. It is shown that the lower topology on a
partial order is T₀ and the complements of the upper closures of finite subsets form a basis.

## References

* [Gierz et al, A Compendium of Continuous Lattices][GierzEtAl1980]

## Tags

lower topology, preorder
-/

universe u

variable (α : Type u)

open set topological_space

section preorder

/--
Type synonym for a preorder equipped with the lower topology
-/
def with_lower_topology := α

instance [p : preorder α] : preorder (with_lower_topology α) := p
instance [p : nonempty α] : nonempty (with_lower_topology α) := p
instance [p : inhabited α] : inhabited (with_lower_topology α) := p
instance [preorder α] [p : order_bot α] : order_bot (with_lower_topology α) := p
instance [p: has_inf α] : has_inf (with_lower_topology α) := p
instance [p: has_Inf α] : has_Inf (with_lower_topology α) := p
instance [p: complete_lattice α] : complete_lattice (with_lower_topology α) := p
instance [p: semilattice_inf α] : semilattice_inf (with_lower_topology α) := p

@[simp] lemma mem_set_of_eq' {x : set (with_lower_topology α)} {p : set α → Prop} :
  x ∈ {y | p y} = p x := rfl

/--
The lower topology is the topology generated by the complements of the closed intervals to infinity.
-/
def lower_topology [preorder α] : topological_space α := generate_from {s | ∃ a, (Ici a)ᶜ = s}

instance [preorder α] : topological_space (with_lower_topology α) := lower_topology α

namespace with_lower_topology

variable {α}

/-- `to_lower` is the identity function to the `with_lower_topology` of a type.  -/
@[pattern] def to_lower : α ≃ with_lower_topology α := equiv.refl _

/-- `of_lower` is the identity function from the `with_lower_topology` of a type.  -/
@[pattern] def of_lower : with_lower_topology α ≃ α := equiv.refl _

@[simp] lemma to_with_lower_topology_symm_eq : (@to_lower α).symm = @of_lower α := rfl
@[simp] lemma of_with_lower_topology_symm_eq : (@of_lower α).symm = @to_lower α := rfl
@[simp] lemma to_lower_of_lower (a : with_lower_topology α) : to_lower (of_lower a) = a := rfl
@[simp] lemma of_lower_to_lower (a : α) : of_lower (to_lower a) = a := rfl
@[simp] lemma to_lower_inj {a b : α} : to_lower a = to_lower b ↔ a = b := iff.rfl
@[simp] lemma of_lower_inj {a b : with_lower_topology α} : of_lower a = of_lower b ↔ a = b :=
iff.rfl

/-- A recursor for `with_lower_topology`. Use as `induction x using with_lower_topology.rec`. -/
protected def rec {β : with_lower_topology α → Sort*}
  (h : Π a, β (to_lower a)) : Π a, β a := λ a, h (of_lower a)

variable [preorder α]

lemma is_open_iff_generate_Ici_comp {s : set (with_lower_topology α)} :
  is_open s ↔ generate_open {s | ∃ a, (Ici a)ᶜ = s} s := iff.rfl

/--
Left-closed right-infinite intervals [a,∞) are closed in the lower topology.
-/
lemma is_closed_Ici (a : with_lower_topology α) : is_closed (Ici a) :=
is_open_compl_iff.1 $ generate_open.basic _ ⟨a, rfl⟩

/--
The upper closure of a finite subset is closed in the lower topology.
-/
lemma is_closed_upper_closure (F : set (with_lower_topology α)) (h : F.finite) :
  is_closed (upper_closure F : set (with_lower_topology α)) :=
begin
  simp only [← upper_set.infi_Ici, upper_set.coe_infi],
  exact is_closed_bUnion h (λ a h₁, is_closed_Ici a),
end

/--
Every subset open in the lower topology is a lower set.
-/
lemma is_lower_set_of_is_open {s : set (with_lower_topology α)} (h : is_open s) : is_lower_set s :=
begin
  rw is_open_iff_generate_Ici_comp at h,
  induction h,
  case generate_open.basic : u h { obtain ⟨a, rfl⟩ := h, exact (is_upper_set_Ici a).compl },
  case univ : { exact is_lower_set_univ },
  case inter : u v hu1 hv1 hu2 hv2 { exact hu2.inter hv2 },
  case sUnion : _ _ ih { exact is_lower_set_sUnion ih },
end

lemma is_upper_set_of_is_closed {s : set (with_lower_topology α)} (h : is_closed s) :
  is_upper_set s := is_lower_set_compl.1 $ is_lower_set_of_is_open h.is_open_compl

/--
The closure of a singleton {a} in the lower topology is the left-closed right-infinite interval
[a,∞).
-/
@[simp] lemma closure_singleton (a : with_lower_topology α) : closure {a} = Ici a :=
subset_antisymm (closure_minimal (λ b h, h.ge) $ is_closed_Ici a) $
  (is_upper_set_of_is_closed is_closed_closure).Ici_subset (subset_closure rfl)

/--
The complements of the upper closures of finite subsets are a collection of lower sets
which form a basis for the lower topology.
-/
def lower_basis (α : Type u) [preorder α] :=
{s : set α | ∃ (F : set α), F.finite ∧ ↑(upper_closure F).compl = s}

protected lemma is_topological_basis :
  is_topological_basis (lower_basis (with_lower_topology α)) :=
begin
  convert is_topological_basis_of_subbasis rfl,
  simp_rw [lower_basis, upper_set.coe_compl, coe_upper_closure, compl_set_of],
  push_neg, simp_rw set_of_forall,
  ext s, split,
  { rintro ⟨F, hF, rfl⟩,
    refine ⟨(λ a, (Ici a)ᶜ) '' F, ⟨hF.image _, image_subset_iff.2 $ λ _ _, ⟨_, rfl⟩⟩, _⟩,
    rw sInter_image, refl },
  { rintro ⟨F, ⟨hF, hs⟩, rfl⟩,
    haveI := hF.to_subtype,
    rw [subset_def, subtype.forall'] at hs,
    choose f he using hs,
    refine ⟨_, finite_range f, set.ext $ λ a, _⟩,
    simp_rw [bInter_range, Inter_subtype, ←compl_set_of, Ici_def, he, mem_Inter₂],
    refl },
end

end with_lower_topology

end preorder

section partial_order

variables (α) [partial_order α]

instance : partial_order (with_lower_topology α) := ‹partial_order α›

/--
The lower topology on a partial order is T₀.
-/
@[priority 90] -- see Note [lower instance priority]
instance : t0_space (with_lower_topology α) :=
(t0_space_iff_inseparable _).2 $ λ x y h, by simpa only
  [inseparable_iff_closure_eq, with_lower_topology.closure_singleton, Ici_inj] using h

end partial_order

section prod

universes v

variable (β : Type v)

lemma of_lower_prod : (@with_lower_topology.of_lower (α × β)) =
  equiv.prod_congr (@with_lower_topology.of_lower α) (@with_lower_topology.of_lower β) :=
begin
  ext,
  { simp only [equiv.prod_congr_apply, prod_map], exact rfl, },
  { simp only [equiv.prod_congr_apply, prod_map], exact rfl, },
end

@[simp] lemma to_lower_prod_to_lower_of_lower :
  (with_lower_topology.to_lower.prod_congr with_lower_topology.to_lower)
  ∘ with_lower_topology.of_lower = @id (α × β) :=
begin
  ext,
  { simp only [function.comp_app, equiv.prod_congr_apply, prod_map, id.def], exact rfl, },
  { simp only [function.comp_app, equiv.prod_congr_apply, prod_map, id.def], exact rfl, },
end

@[simp] lemma of_lower_to_lower_prod_to_lower' : (with_lower_topology.of_lower.trans
  (with_lower_topology.to_lower.prod_congr with_lower_topology.to_lower)) = @equiv.refl (α × β) :=
begin
  ext,
  { simp only [equiv.coe_trans, to_lower_prod_to_lower_of_lower, equiv.coe_refl], },
  { simp only [equiv.coe_trans, to_lower_prod_to_lower_of_lower, equiv.coe_refl], }
end

-- Why doesn't equiv.refl_symm work?
@[simp] lemma refl_symm : (equiv.refl (α × β)).symm = @equiv.refl (α × β) := rfl

section partial_order

variables [partial_order α] [partial_order β]

lemma prod_basis_is_topological_basis : is_topological_basis
    (image2 prod (with_lower_topology.lower_basis (with_lower_topology α))
       (with_lower_topology.lower_basis (with_lower_topology β))) :=
is_topological_basis.prod with_lower_topology.is_topological_basis
  with_lower_topology.is_topological_basis

lemma upper_closure_prod_upper_closure (F₁ : set α) (F₂ : set β) :
  (upper_closure F₁).prod (upper_closure F₂)  =
  (⊥ : upper_set α).prod (upper_closure F₂) ⊔ (upper_closure F₁).prod (⊥ : upper_set β) :=
upper_set.ext begin
  rw subset_antisymm_iff,
  split,
  { rintros x h,
    finish, },
  { rintros x h,
    finish, },
end

lemma upper_closure_set_prod (F₁ : set α) (F₂ : set β) :
  upper_closure (F₁ ×ˢ F₂)  =
  (⊥ : upper_set α).prod (upper_closure F₂) ⊔ (upper_closure F₁).prod (⊥ : upper_set β) :=
by rw [upper_closure_prod, upper_closure_prod_upper_closure]

lemma prod_Ici (a : α) (b : β) : upper_set.Ici (a,b) =
    (⊥ : upper_set α).prod (upper_set.Ici b) ⊔ (upper_set.Ici a).prod (⊥ : upper_set β) :=
by rw [← upper_set.Ici_prod_Ici, ← upper_closure_singleton, ← upper_closure_singleton,
    upper_closure_prod_upper_closure]

lemma upper_closure_compl_prod_upper_closure_compl (F₁ : set α) (F₂ : set β) :
  ((upper_closure F₁).compl.prod (upper_closure F₂).compl) =
  (((⊥ : upper_set α).prod (upper_closure F₂)).compl ⊓
  ((upper_closure F₁).prod (⊥ : upper_set β)).compl) :=
lower_set.ext begin
  rw subset_antisymm_iff,
  split,
  { rintros x h,
    finish, },
  { rintros x h,
    simp,
    simp at h,
    rw and_comm,
    exact h, }
end

lemma upper_closure_compl_prod_upper_closure_compl' (F₁ : set α) (F₂ : set β)
  : ((upper_closure F₁).compl.prod (upper_closure F₂).compl)  =
  (upper_closure (univ ×ˢ F₂)).compl ⊓ (upper_closure (F₁ ×ˢ univ)).compl :=
begin
  rw upper_closure_compl_prod_upper_closure_compl,
  simp only [upper_closure_prod, upper_closure_univ],
end

lemma upper_closure_compl_prod_upper_closure_compl'' {α : Type u} {β : Type v}
  [complete_lattice α] [complete_lattice β] (F₁ : set α) (F₂ : set β) :
  ((upper_closure F₁).compl.prod (upper_closure F₂).compl)  =
  (upper_closure ({(⊥ : α)} ×ˢ F₂)).compl ⊓ (upper_closure (F₁ ×ˢ {(⊥ : β)})).compl :=
by rw [upper_closure_compl_prod_upper_closure_compl, upper_closure_prod, upper_closure_prod,
    upper_closure_singleton, upper_closure_singleton, upper_set.Ici_bot, upper_set.Ici_bot]

lemma lower_topology_prod  [order_bot α] [order_bot β] :
  with_lower_topology.topological_space (α × β) =
  @prod.topological_space α β (lower_topology α) (lower_topology β) :=
begin
  rw le_antisymm_iff,
  split,
    { rw (prod_basis_is_topological_basis α β).eq_generate_from,
      apply le_generate_from,
      intros U hU,
      simp only [mem_image2, exists_and_distrib_left] at hU,
      cases hU with V,
      cases hU_h with hV,
      cases hU_h_right with W,
      cases hU_h_right_h with hW hUVW,
      rw ← hUVW,
      rw [with_lower_topology.lower_basis, mem_set_of_eq] at hV,
      cases hV with F₁,
      rw [with_lower_topology.lower_basis, mem_set_of_eq]  at hW,
      cases hW with F₂,
      rw [← hV_h.2, ← hW_h.2, ← lower_set.coe_prod, upper_closure_compl_prod_upper_closure_compl',
        lower_set.coe_inf],
      apply is_open.inter,
      { rw  [upper_set.coe_compl, is_open_compl_iff, upper_closure_prod, upper_closure_univ,
          ← upper_set.Ici_bot, ← upper_closure_singleton, ← upper_closure_prod],
        apply with_lower_topology.is_closed_upper_closure,
        apply set.finite.prod (finite_singleton ⊥) hW_h.1, },
      { rw  [upper_set.coe_compl, is_open_compl_iff, upper_closure_prod, upper_closure_univ,
          ← upper_set.Ici_bot, ← upper_closure_singleton, ← upper_closure_prod],
       apply with_lower_topology.is_closed_upper_closure,
       apply set.finite.prod hV_h.1 (finite_singleton ⊥), }, },
    { apply le_generate_from,
    intros,
    rw mem_set_of_eq at H,
    rcases H,
    cases H_w with a b,
    rw [← H_h, ← upper_set.coe_Ici, is_open_compl_iff, prod_Ici],
    apply is_closed.inter,
    { apply is_closed.prod is_closed_univ, apply with_lower_topology.is_closed_Ici, },
    { apply is_closed.prod, apply with_lower_topology.is_closed_Ici, apply is_closed_univ, } },
end

/--
The lower topology of the partially ordered space α × β is homeomorphic to the product topology of
the lower topology of the partially ordered space α with the lower topology of the partially ordered
space β
-/
def lower_topology_prod_hom [order_bot α] [order_bot β] :
  with_lower_topology (α × β) ≃ₜ ((with_lower_topology α) × (with_lower_topology β)) :=
{ continuous_to_fun :=
  begin
    simp only [equiv.to_fun_as_coe, equiv.coe_trans, to_lower_prod_to_lower_of_lower],
    convert continuous_id,
    rw lower_topology_prod,
  end,
  continuous_inv_fun :=
  begin
    simp only [of_lower_to_lower_prod_to_lower', equiv.inv_fun_as_coe, refl_symm, equiv.coe_refl],
    convert continuous_id,
    rw lower_topology_prod,
  end,
  ..with_lower_topology.of_lower.trans (with_lower_topology.to_lower.prod_congr
    with_lower_topology.to_lower) }

end partial_order

section complete_lattice

variables {α} {β}

variables [complete_lattice α] [complete_lattice β]

lemma inf_hom_monotone (f : Inf_hom (with_lower_topology α) (with_lower_topology β)) :
monotone f := order_hom_class.mono f

lemma inf_hom_continuous (f : Inf_hom (with_lower_topology α) (with_lower_topology β)) :
  continuous f :=
begin
  apply continuous_generated_from,
  intros s hs,
  rw mem_set_of_eq' at hs,
  cases hs with a,
  rw ← hs_h,
  rw ← is_closed_compl_iff,
  simp only [preimage_compl, compl_compl],
  let p :=  Inf (f ⁻¹' Ici a),
  have e1: f ⁻¹' Ici a = Ici p :=
  begin
    rw subset_antisymm_iff,
    split,
    { intros x hx,
      rw mem_Ici,
      exact Inf_le hx, },
    { intros x hx,
      simp only [mem_preimage, mem_Ici],
      rw mem_Ici at hx,
      have p_def: p = Inf (f ⁻¹' Ici a) := rfl,
      have e1: a ≤ f(p) := begin
        rw p_def,
        simp only [map_Inf, ge_iff_le, le_Inf_iff, mem_image, mem_preimage, mem_Ici,
          forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, imp_self, forall_const],
      end,
      apply le_trans e1 (inf_hom_monotone f hx), },
  end,
  rw e1,
  exact with_lower_topology.is_closed_Ici p
end

end complete_lattice

end prod

section complete_lattice

variable [complete_lattice α]

def inf_Inf_hom : Inf_hom (with_lower_topology (α × α)) (with_lower_topology α) :=
{ to_fun := λ (p : with_lower_topology (α × α)), (p.fst ⊓ p.snd : with_lower_topology α),
  map_Inf' := λ s, begin
    rw le_antisymm_iff,
    split,
    { simp only [le_Inf_iff, mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,
        le_inf_iff],
      intros a ha,
      split,
      { exact inf_le_of_left_le (monotone_fst (Inf_le ha)), },
      { exact inf_le_of_right_le (monotone_snd (Inf_le ha)), }, },
    { rw Inf_le_iff,
      intros b hb,
      rw mem_lower_bounds at hb,
      simp only
        [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, le_inf_iff] at hb,
      have h₂ : (b,b) ≤ Inf s :=
      begin
        rw le_Inf_iff,
        exact hb,
      end,
      rw le_inf_iff,
      apply h₂, }
  end, }

lemma with_lower_topology.continuous_inf: continuous (inf_Inf_hom α) :=
inf_hom_continuous (inf_Inf_hom α)

instance : has_continuous_inf (with_lower_topology α) :=
{ continuous_inf := begin
    rw ← lower_topology_prod,
    apply with_lower_topology.continuous_inf,
  end }

lemma sUnion_Ici_compl  (s : set α):
  ⋃₀ { (Ici a)ᶜ | a ∈ s } = (Ici (Sup s))ᶜ :=
begin
  rw subset_antisymm_iff,
  split,
  { rw sUnion_subset_iff,
    simp only [mem_set_of_eq, forall_exists_index, forall_apply_eq_imp_iff₂, compl_subset_compl],
    rintro a h,
    rw Ici_subset_Ici,
    apply le_Sup h, },
  { rintro a h,
    simp only [exists_prop, mem_sUnion, mem_set_of_eq, exists_exists_and_eq_and, mem_compl_iff,
      mem_Ici],
    simp only [mem_compl_iff, mem_Ici, Sup_le_iff, not_forall, exists_prop] at h,
    exact h, }
end

end complete_lattice

section prime

variables [has_inf α] [has_le α]

/--
An element `a` is said to be prime if whenever `a ≤ b ⊓ c` at least one of `a ≤ b`, `a ≤ c` holds.
-/
def is_prime (a : α) : Prop := ∀ b c, a ≤ b ⊓ c → a ≤ b ∨ a ≤ c

/-
The subtype of prime elements of a partial order with inf
-/
-- def prime (β : Type u) [has_inf β] [has_le β] := {a : β // is_prime a}

end prime
