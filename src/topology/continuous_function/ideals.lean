/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/

import topology.continuous_function.compact
import topology.urysohns_lemma
import data.complex.is_R_or_C

/-!
# Ideals of continuous functions

## Main definitions

* `continuous_map.ideal_of_set`
* `continuous_map.set_of_ideal`

## Main statements

* ``

## Implementation details



## References

* [F. Bar, *Quuxes*][bibkey]

## Tags

Foobars, barfoos
-/

open_locale nnreal

namespace continuous_map
variables {X R : Type*} [topological_space X] [ring R] [topological_space R] [topological_ring R]

variable (R)

/-- Given a topological ring `R` and `s : set X`, construct the ideal in `C(X, R)` of functions
which vanish on the complement of `s`. -/
def ideal_of_set (s : set X) : ideal C(X, R) :=
{ carrier := {f : C(X, R) | ‚àÄ x ‚àà s·∂ú, f x = 0},
  add_mem' := Œª f g hf hg x hx, by simp only [hf x hx, hg x hx, coe_add, pi.add_apply, add_zero],
  zero_mem' := by simp only [set.mem_set_of_eq, coe_zero, pi.zero_apply, eq_self_iff_true, implies_true_iff],
  smul_mem' := Œª c f hf x hx, mul_zero (c x) ‚ñ∏ congr_arg (Œª y, c x * y) (hf x hx), }

variable {R}

lemma mem_ideal_of_set {s : set X} {f : C(X, R)} :
  f ‚àà ideal_of_set R s ‚Üî ‚àÄ ‚¶Éx : X‚¶Ñ, x ‚àà s·∂ú ‚Üí f x = 0 := iff.rfl

lemma not_mem_ideal_of_set {s : set X} {f : C(X, R)} :
  f ‚àâ ideal_of_set R s ‚Üî ‚àÉ x ‚àà s·∂ú, f x ‚â† 0 :=
by { simp_rw [mem_ideal_of_set, exists_prop], push_neg }

lemma ideal_of_set_closed [locally_compact_space X] [t2_space R] (s : set X) :
  is_closed (ideal_of_set R s : set C(X, R) ) :=
begin
  simp only [ideal_of_set, submodule.coe_set_mk, set.set_of_forall],
  exact is_closed_Inter (Œª x, is_closed_Inter $
    Œª hx, is_closed_eq (continuous_eval_const' x) continuous_const),
end

/-- Given an ideal `I` of `C(X, R)`, construct the set of points for which every function in the
ideal vanishes on the complement. -/
def set_of_ideal (I : ideal C(X, R)) : set X :=
{x : X | ‚àÄ f ‚àà I, (f : C(X, R)) x = 0}·∂ú

lemma not_mem_set_of_ideal {I : ideal C(X, R)} {x : X} :
  x ‚àâ set_of_ideal I ‚Üî ‚àÄ ‚¶Éf : C(X, R)‚¶Ñ, f ‚àà I ‚Üí f x = 0 :=
by rw [‚Üêset.mem_compl_iff, set_of_ideal, compl_compl, set.mem_set_of]

lemma mem_set_of_ideal {I : ideal C(X, R)} {x : X} :
  x ‚àà set_of_ideal I ‚Üî ‚àÉ f ‚àà I, (f : C(X, R)) x ‚â† 0 :=
by { simp_rw [set_of_ideal, set.mem_compl_iff, set.mem_set_of, exists_prop], push_neg }

lemma set_of_ideal_open [t2_space R] (I : ideal C(X, R)) : is_open (set_of_ideal I) :=
begin
  simp only [set_of_ideal, set.set_of_forall, is_open_compl_iff],
  exact is_closed_Inter (Œª f, is_closed_Inter $
    Œª hf, is_closed_eq (map_continuous f) continuous_const)
end

variables (X R)
lemma gc : galois_connection (set_of_ideal : ideal C(X, R) ‚Üí set X) (ideal_of_set R) :=
begin
  refine Œª I s, ‚ü®Œª h f hf, _, Œª h x hx, _‚ü©,
  { by_contra h',
    rcases not_mem_ideal_of_set.mp h' with ‚ü®x, hx, hfx‚ü©,
    exact hfx (not_mem_set_of_ideal.mp (mt (@h x) hx) hf) },
  { obtain ‚ü®f, hf, hfx‚ü© := mem_set_of_ideal.mp hx,
    by_contra hx',
    exact not_mem_ideal_of_set.mpr ‚ü®x, hx', hfx‚ü© (h hf) },
end

theorem nnnorm_lt_iff {Œ± E : Type*} [topological_space Œ±] [compact_space Œ±]
  [normed_add_comm_group E] (f : C(Œ±, E)) {M : ‚Ñù‚â•0} (M0 : 0 < M) :
‚à•f‚à•‚Çä < M ‚Üî ‚àÄ (x : Œ±), ‚à•f x‚à•‚Çä < M :=
f.norm_lt_iff M0

end continuous_map

namespace continuous_map

variables {X ùïú A : Type*} [is_R_or_C ùïú] [topological_space X] [normed_ring A] [star_ring A]
variables [cstar_ring A] [normed_algebra ùïú A] [hùïúA : star_module ùïú A]
open is_R_or_C

lemma main_lemma_aux (f : C(X, ‚Ñù‚â•0)) {c : ‚Ñù‚â•0} (hc : 0 < c) :
  ‚àÉ g : C(X, ‚Ñù‚â•0), (‚àÄ x : X, (g * f) x ‚â§ 1) ‚àß {x : X | c ‚â§ f x}.eq_on (g * f) 1 :=
begin
  refine ‚ü®‚ü®(f ‚äî (const X c))‚Åª¬π, continuous.inv‚ÇÄ ((map_continuous f).sup $ map_continuous _)
    (Œª x, (hc.trans_le le_sup_right).ne')‚ü©, Œª x, _, _‚ü©,
  exact (inv_mul_le_iff (hc.trans_le le_sup_right)).mpr ((mul_one (f x ‚äî c)).symm ‚ñ∏ le_sup_left),
  intros x hx,
  simpa only [coe_const, coe_mk, pi.mul_apply, pi.inv_apply, pi.sup_apply, function.const_apply,
    pi.one_apply, sup_eq_left.mpr (set.mem_set_of.mp hx)]
  using inv_mul_cancel (hc.trans_le hx).ne',
end

lemma ideal_of_set_of_le_closure [compact_space X] (I : ideal C(X, ùïú)) :
  ideal_of_set ùïú (set_of_ideal I) ‚â§ I.closure :=
begin
  /- given `f ‚àà ideal_of_set ùïú (set_of_ideal I)` and `(Œµ : ‚Ñù‚â•0) > 0` it suffices to show that
  `f` is within `Œµ` of `I`. Let `t := {x : X | Œµ / 2 ‚â§ ‚à•f x‚à•‚Çä}}` which is closed and disjoint from
  `set_of_ideal I`. -/
  refine Œª f hf, metric.mem_closure_iff.mpr (Œª Œµ hŒµ, _),
  lift Œµ to ‚Ñù‚â•0 using hŒµ.lt.le,
  replace hŒµ := (show (0 : ‚Ñù‚â•0) < Œµ, from hŒµ),
  simp_rw dist_nndist,
  norm_cast,
  set t := {x : X | Œµ / 2 ‚â§ ‚à•f x‚à•‚Çä},
  have ht : is_closed t := is_closed_le continuous_const (map_continuous f).nnnorm,
  have htI : disjoint t (set_of_ideal I)·∂ú,
  { refine set.subset_compl_iff_disjoint_left.mp (Œª x hx, _),
    simpa only [t, set.mem_set_of, set.mem_compl_iff, not_le]
      using (nnnorm_eq_zero.mpr (mem_ideal_of_set.mp hf hx)).trans_lt (half_pos hŒµ), },
  /- It suffices to produce `g : C(X, ‚Ñù‚â•0)` which takes values in `[0,1]` and is constantly `1` on
  `t` such that when composed with the natural embedding of `‚Ñù‚â•0` into `ùïú` lies in the ideal `I`.
  Indeed, then `‚à•f - f * ‚Üëg‚à• ‚â§ ‚à•f * (1 - ‚Üëg)‚à• ‚â§ ‚®Ü ‚à•f * (1 - ‚Üëg) x‚à•`. When `x ‚àâ t`, `‚à•f x‚à• < Œµ / 2`
  and `‚à•(1 - ‚Üëg) x‚à• ‚â§ 1`, and when `x ‚àà t`, `(1 - ‚Üëg) x = 0`, and clearly `f * ‚Üëg ‚àà I`. -/
  suffices : ‚àÉ g : C(X, ‚Ñù‚â•0), of_nnreal_cm.comp g ‚àà I ‚àß (‚àÄ x, g x ‚â§ 1) ‚àß t.eq_on g 1,
  { obtain ‚ü®g, hgI, hg, hgt‚ü© := this,
    refine ‚ü®f * of_nnreal_cm.comp g, I.mul_mem_left f hgI, _‚ü©,
    rw nndist_eq_nnnorm,
    refine (nnnorm_lt_iff _ hŒµ).2 (Œª x, _),
    simp only [coe_sub, coe_mul, pi.sub_apply, pi.mul_apply],
    by_cases hx : x ‚àà t,
    { simpa only [hgt hx, pi.one_apply, mul_one, sub_self, nnnorm_zero, comp_apply,
        of_nnreal_cm_coe, map_one] using hŒµ },
    { refine lt_of_le_of_lt _ (half_lt_self hŒµ),
      have : ‚à•((1 - of_nnreal_cm.comp g) x : ùïú)‚à•‚Çä ‚â§ 1,
      { simp only [coe_sub, coe_one, pi.sub_apply, pi.one_apply, comp_apply,
          of_nnreal_cm_coe, ‚Üê(map_one of_nnreal_am), of_nnreal_am_coe, coe_coe],
        rw [‚Üêis_R_or_C.of_real_one, ‚Üênnreal.coe_one, ‚Üêof_real_sub, ‚Üênnreal.coe_sub (hg x)],
        rw [nnnorm_of_nnreal (1 - g x)],
        exact tsub_le_self, },
      calc ‚à•f x - f x * of_nnreal_cm.comp g x‚à•‚Çä
          = ‚à•f x * (1 - of_nnreal_cm.comp g) x‚à•‚Çä
          : by simp only [mul_sub, coe_sub, coe_one, pi.sub_apply, pi.one_apply, mul_one]
      ... ‚â§ (Œµ / 2) * ‚à•(1 - of_nnreal_cm.comp g) x‚à•‚Çä
          : (nnnorm_mul_le _ _).trans (mul_le_mul_right'
              (not_le.mp $ show ¬¨ Œµ / 2 ‚â§ ‚à•f x‚à•‚Çä, from hx).le _)
      ... ‚â§ Œµ / 2 : by simpa only [mul_one] using mul_le_mul_left' this _, } },
  /- There is some `g' : C(X, ‚Ñù‚â•0)` which is strictly positive on `t` such that the composition
  `‚Üëg` with the natural embedding of `‚Ñù‚â•0` into `ùïú` lies in `I`. This follows from compactness of
  `t` and that we can do it in any neighborhood of a point `x ‚àà t`. Indeed, since `x ‚àà t`, then
  `f‚Çì x ‚â† 0` for some `f‚Çì ‚àà I` and so `Œª y, ‚à•(star f‚Çì * f‚Çì) y‚à•‚Çä` is strictly posiive in a
  neighborhood of `y`. Moreover, `(‚à•(star f‚Çì * f‚Çì) y‚à•‚Çä : ùïú) = (star f‚Çì * f‚Çì) y`, so composition of
  this map with the natural embedding is just `star f‚Çì * f‚Çì ‚àà I`. -/
  have : ‚àÉ g' : C(X, ‚Ñù‚â•0), of_nnreal_cm.comp g' ‚àà I ‚àß (‚àÄ x ‚àà t, 0 < g' x),
  { refine @is_compact.induction_on _ _ _ ht.is_compact
      (Œª s, ‚àÉ g' : C(X, ‚Ñù‚â•0), of_nnreal_cm.comp g' ‚àà I ‚àß (‚àÄ x ‚àà s, 0 < g' x)) _ _ _ _,
    { refine ‚ü®0, by { convert I.zero_mem, ext, simp only [comp_apply, coe_zero, pi.zero_apply,
        of_nnreal_cm_coe, map_zero]}, Œª x hx, false.elim hx‚ü©, },
    { rintro s‚ÇÅ s‚ÇÇ hs ‚ü®g, hI, hgt‚ü©, exact ‚ü®g, hI, Œª x hx, hgt x (hs hx)‚ü©, },
    { rintro s‚ÇÅ s‚ÇÇ ‚ü®g‚ÇÅ, hI‚ÇÅ, hgt‚ÇÅ‚ü© ‚ü®g‚ÇÇ, hI‚ÇÇ, hgt‚ÇÇ‚ü©,
      refine ‚ü®g‚ÇÅ + g‚ÇÇ, _, Œª x hx, _‚ü©,
      convert I.add_mem hI‚ÇÅ hI‚ÇÇ,
      ext y,
      simp only [coe_add, pi.add_apply, of_nnreal_cm_coe, map_add, coe_comp, function.comp_app],
      rcases hx with (hx | hx),
      simpa only [zero_add] using add_lt_add_of_lt_of_le (hgt‚ÇÅ x hx) zero_le',
      simpa only [zero_add] using add_lt_add_of_le_of_lt zero_le' (hgt‚ÇÇ x hx), },
    { intros x hx,
      replace hx := htI.subset_compl_right hx,
      rw [compl_compl, mem_set_of_ideal] at hx,
      obtain ‚ü®g, hI, hgx‚ü© := hx,
      have := (map_continuous g).continuous_at.eventually_ne hgx,
      refine ‚ü®{y : X | g y ‚â† 0} ‚à© t, mem_nhds_within_iff_exists_mem_nhds_inter.mpr
        ‚ü®_, this, set.subset.rfl‚ü©, ‚ü®‚ü®Œª x, ‚à•g x‚à•‚Çä ^ 2, (map_continuous g).nnnorm.pow 2‚ü©, _,
        Œª x hx, pow_pos (norm_pos_iff.mpr hx.1) 2‚ü©‚ü©,
      convert I.mul_mem_left (star g) hI,
      ext,
      simp only [comp_apply, coe_mk, of_nnreal_cm_coe, map_pow, coe_mul, coe_star,
        pi.mul_apply, pi.star_apply, star_def],
      simp only [of_nnreal_am_coe, coe_coe, coe_nnnorm, norm_sq_eq_def', conj_mul_eq_norm_sq_left,
        of_real_pow], }, },
  /- Get the function `g'` which is guaranteed to exist above. By the extreme value theorem and
  compactness of `t`, there is some `0 < c` such that `c ‚â§ g' x` for all `x ‚àà t`. Then by
  `main_lemma_aux` there is some `g` for which `g * g'` is the desired function. -/
  obtain ‚ü®g', hI', hgt'‚ü© := this,
  obtain (‚ü®c, hc, hgc'‚ü© : ‚àÉ c (hc : 0 < c), ‚àÄ y : X, y ‚àà t ‚Üí c ‚â§ g' y) :=
  t.eq_empty_or_nonempty.elim (Œª ht', ‚ü®1, zero_lt_one, Œª y hy, false.elim (by rwa ht' at hy)‚ü©)
    (Œª ht', let ‚ü®x, hx, hx'‚ü© := ht.is_compact.exists_forall_le ht' (map_continuous g').continuous_on
      in ‚ü®g' x, hgt' x hx, hx'‚ü©),
  obtain ‚ü®g, hg, hgc‚ü© := main_lemma_aux g' hc,
  refine ‚ü®g * g', _, hg, hgc.mono hgc'‚ü©,
  convert I.mul_mem_left (of_nnreal_cm.comp g) hI',
  ext,
  simp only [of_nnreal_cm_coe, comp_apply, coe_mul, pi.mul_apply, map_mul],
end

@[simp] lemma ideal_of_set_of_is_closed [compact_space X] {I : ideal C(X, ùïú)}
  (hI : is_closed (I : set C(X, ùïú))) : ideal_of_set ùïú (set_of_ideal I) = I :=
le_antisymm ((ideal_of_set_of_le_closure I).trans $ closure_subset_iff_is_closed.mpr hI)
  ((gc X ùïú).le_u_l I)

lemma interior_subset_of_ideal_of_set [compact_space X] [t2_space X] (s : set X) :
  interior s ‚äÜ set_of_ideal (ideal_of_set ùïú s) :=
begin
  /- If `x ‚àâ closure s·∂ú`, we must produce `f : C(X, ùïú)` which is zero on `s·∂ú` and `f x ‚â† 0`. -/
  rw [‚Üêcompl_compl (interior s), ‚Üêclosure_compl],
  intros x hx,
  simp_rw [mem_set_of_ideal, mem_ideal_of_set],
  haveI : normal_space X := normal_of_compact_t2,
  /- Apply Urysohn's lemma to get `g : C(X, ‚Ñù)` which is zero on `s·∂ú` and `g x ‚â† 0`, then compose
  with the natural embedding `‚Ñù ‚Ü™ ùïú` to produce the desired `f`. -/
  obtain ‚ü®g, hgs, (hgx : set.eq_on g 1 {x}), -‚ü© := exists_continuous_zero_one_of_closed
    is_closed_closure is_closed_singleton (set.disjoint_singleton_right.mpr hx),
  exact ‚ü®‚ü®Œª x, g x, continuous_of_real.comp (map_continuous g)‚ü©,
    by simpa only [coe_mk, of_real_eq_zero] using Œª x hx, hgs (subset_closure hx),
    by simpa only [coe_mk, hgx (set.mem_singleton x), pi.one_apply, is_R_or_C.of_real_one]
      using one_ne_zero‚ü©,
end

@[simp] lemma set_of_ideal_of_is_open [compact_space X] [t2_space X] {s : set X} (hs : is_open s) :
  set_of_ideal (ideal_of_set ùïú s) = s :=
le_antisymm ((gc X ùïú).l_u_le s)
  (by simpa only [hs.interior_eq] using (interior_subset_of_ideal_of_set s))

end continuous_map
