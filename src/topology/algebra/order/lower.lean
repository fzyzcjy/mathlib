/-
Copyright (c) 2022 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/

import topology.basic
import topology.order
import data.set.intervals.basic
import order.upper_lower

/-!
# Lower topology

This file introduces the lower topology on a preorder

## References

* [Gierz et al, A Compendium of Continuous Lattices][GierzEtAl1980]
-/

universes u
variables {α : Type u}

open  set topological_space

-- def Ici (a : α) := {x | a ≤ x}

lemma ici_comp_is_lower [preorder α] (a : α) : is_lower_set (Ici a)ᶜ :=
begin
  intro c,
  finish,
end

/--
The lower topology is the topology generated by the complements of the closed intervals to infinity
-/
class lower_topology (α : Type*) [t : topological_space α] [preorder α] : Prop :=
(topology_eq_generate_Ici_comp : t = generate_from {s | ∃a, s = (Ici a)ᶜ })

section lower_topology

variables [topological_space α] [partial_order α] [t : lower_topology α]

include t

lemma is_open_iff_generate_Ici_comp {s : set α} :
  is_open s ↔ generate_open {s | ∃a, s = (Ici a)ᶜ} s :=
by rw [t.topology_eq_generate_Ici_comp]; refl

lemma lower_open_is_lower {s : set α} (h: is_open s) : is_lower_set s :=
begin
  rw is_open_iff_generate_Ici_comp at h,
  induction h,
  case topological_space.generate_open.basic : u
  { rw mem_set_of_eq at h_H,
    choose a h_H using h_H,
    rw h_H,
    apply ici_comp_is_lower a, },
  case topological_space.generate_open.univ : { exact is_lower_set_univ },
  case topological_space.generate_open.inter : u v hu1 hv1 hu2 hv2
    { apply is_lower_set.inter hu2 hv2 },
  case topological_space.generate_open.sUnion : { apply is_lower_set_sUnion h_ih, },
end

-- II 14th Dec 2001 Lawson = Fell
-- III 6th July 2002 Primitive nets
-- IV 15th Jan 2003 Deduce Fell

lemma ici_is_closed (b : α) : is_closed (Ici b)  :=
begin
  rw [← is_open_compl_iff, is_open_iff_generate_Ici_comp],
  fconstructor,
  rw mem_set_of_eq,
  use b,
end

open classical

lemma singleton_closure (a : α) : closure {a} = Ici a :=
begin
  rw subset_antisymm_iff,
  split,
  { apply closure_minimal _ (ici_is_closed a), rw [singleton_subset_iff, mem_Ici], },
  { unfold closure,
    refine subset_sInter _,
    intro u,
    intro h,
    rw mem_set_of_eq at h,
    intro b,
    intro hb,
    rw mem_Ici at hb,
    rw singleton_subset_iff at h,
    rw ← is_open_compl_iff at h,
    by_contradiction H,
    rw ← mem_compl_iff at H,
    have h1: a ∈ uᶜ, from lower_open_is_lower h.left hb H,
    rw mem_compl_iff at h1,
    rw ← not_not_mem at h,
    apply absurd h1 h.right, },
end

end lower_topology
