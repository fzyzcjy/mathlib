/-
Copyright (c) 2022 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/

import topology.basic
import topology.order
import topology.separation
import data.set.intervals.basic
import order.upper_lower

/-!
# Lower topology

This file introduces the lower topology on a preorder

Based on `order_topology` from topology.algebra.order.basic

## References

* [Gierz et al, A Compendium of Continuous Lattices][GierzEtAl1980]
-/

universes u v
variables {α : Type u} {β : Type v}

open  set topological_space

section preorder

@[simp] lemma upper_set.Union_Ici [preorder α] (s : set α) : (⋃ a ∈ s, set.Ici a) =
  (upper_closure s : set α) :=
begin
  rw [← upper_set.infi_Ici, upper_set.coe_infi₂],
  simp only [upper_set.coe_Ici],
end

@[simp] lemma upper_set.Inter_Ici [preorder α] (s : set α) : (⋂ a ∈ s, (set.Ici a)ᶜ) =
  (upper_closure s : set α)ᶜ :=
begin
  rw ← upper_set.Union_Ici,
  simp only [compl_Union],
end

lemma l1 [preorder α] [preorder β] (a : α) (b : β) :
  Ici (a,b) = (univ ×ˢ (Ici b)) ∩ ((Ici a) ×ˢ univ) :=
begin
  rw subset_antisymm_iff,
  split,
  { intros x h, simp, rw mem_Ici at h, rw prod.le_def at h, simp at h, rw and.comm, apply h, },
  { intros x h, simp, simp at h, rw and.comm at h, rw prod.le_def, simp, apply h, }
end

lemma l2 [preorder α] [preorder β] (a : α) (b : β) :
  (Ici a)ᶜ ×ˢ (Ici b)ᶜ = ((univ ×ˢ Ici b) ∪ (Ici a ×ˢ univ))ᶜ :=
begin
  rw subset_antisymm_iff,
  split,
  { intros x h, simp, simp at h, rw and.comm, apply h, },
  { intros x h, simp, simp at h,  rw and.comm, apply h, }
end

lemma upper_closure_comp_prod_upper_closure_comp [preorder α] [preorder β] (F₁ : set α) (F₂ : set β)
  : (upper_closure F₁ : set α)ᶜ ×ˢ (upper_closure F₂ : set β)ᶜ =
  (univ ×ˢ upper_closure F₂ ∪ upper_closure F₁ ×ˢ univ)ᶜ :=
begin
  rw subset_antisymm_iff,
  split,
  { rintros x h,
    finish, },
  { rintros x h,
    finish, }
end

lemma upper_closure_prod [preorder α] [preorder β] (F₁ : set α) (F₂ : set β) :
  (upper_closure (F₁ ×ˢ F₂) : set (α × β)) = ((univ : set α) ×ˢ ((upper_closure F₂) : set β))
  ∩ ((upper_closure F₁ : set α) ×ˢ (univ : set β)) :=
begin
  rw subset_antisymm_iff,
  split,
  { rintros x h,
    simp,
    simp at h,
    cases h with a,
    cases h_h with b,
    cases h_h_h,
    cases h_h_h_right,
    simp only at h_h_h_right_left,
    simp only at h_h_h_right_right,
    split,
    { use b,
      split,
      exact h_h_h_left.2,
      exact h_h_h_right_right, },
    { use a,
      split,
      exact h_h_h_left.1,
      exact h_h_h_right_left, } },
  { rintros p h,
    simp,
    simp at h,
    cases h,
    cases h_left with b,
    cases h_right with a,
    cases h_left_h,
    use a,
    use b,
    split,
    { split,
      exact h_right_h.1,
      exact h_left_h_left, },
    { split,
      { simp only, exact h_right_h.2, },
      { simp only, exact h_left_h_right, }, }, },
end

lemma l2a [preorder β] (b : β) : (univ : set α) ×ˢ (Ici b)ᶜ = (univ ×ˢ Ici b)ᶜ :=
begin
  rw subset_antisymm_iff,
  split,
  { rintros x h,
    simp at h,
    finish, },
  { rintros x h,
    simp at h,
    finish, }
end

lemma l2b [preorder α] (a : α) : (Ici a)ᶜ ×ˢ (univ : set β) = (Ici a ×ˢ univ)ᶜ :=
begin
  rw subset_antisymm_iff,
  split,
  { rintros x h,
    simp at h,
    finish, },
  { rintros x h,
    simp at h,
    finish, }
end

end preorder

-- def Ici (a : α) := {x | a ≤ x}

lemma ici_comp_is_lower [preorder α] (a : α) : is_lower_set (Ici a)ᶜ :=
begin
  intro c,
  finish,
end

/--
The lower topology is the topology generated by the complements of the closed intervals to infinity
-/
class lower_topology (α : Type*) [t : topological_space α] [preorder α] : Prop :=
(topology_eq_generate_Ici_comp : t = generate_from {s | ∃a, s = (Ici a)ᶜ })

section lower_topology

variables [topological_space α] [partial_order α] [t : lower_topology α]

lemma u_union (β : Type*) [complete_lattice β] (s : set β):
  ⋃₀ { (Ici a)ᶜ | a ∈ s } = (Ici (Sup s))ᶜ :=
begin
  rw subset_antisymm_iff,
  split,
  { rw sUnion_subset_iff,
    simp only [mem_set_of_eq, forall_exists_index, forall_apply_eq_imp_iff₂, compl_subset_compl],
    rintro a h,
    rw Ici_subset_Ici,
    apply le_Sup h, },
  { rintro a h,
    simp only [exists_prop, mem_sUnion, mem_set_of_eq, exists_exists_and_eq_and, mem_compl_eq,
      mem_Ici],
    simp only [mem_compl_eq, mem_Ici, Sup_le_iff, not_forall, exists_prop] at h,
    apply h, }
end

lemma pair_union (F₁ F₂ : set α) :
  (upper_closure F₁ : set α)ᶜ ∩ (upper_closure F₂ : set α)ᶜ = (upper_closure (F₁ ∪ F₂) : set α)ᶜ :=
begin
  rw [← compl_union, compl_inj_iff, upper_closure_union],
  simp only [upper_set.coe_inf],
end

lemma univ_empty : (upper_closure (∅ : set α) : set α)ᶜ = univ :=
  by rw [upper_closure_empty, upper_set.coe_top, compl_empty]

lemma upper_closure_singleton (a : α) : upper_set.Ici a = upper_closure {a} :=
begin
  ext,
  rw [upper_set.coe_Ici, coe_upper_closure, mem_Ici, mem_set_of_eq],
  simp only [ mem_singleton_iff, exists_prop, exists_eq_left],
end

#check {s : set α | ∃ (F : set α),  F.finite ∧ s = (upper_closure F : set α)ᶜ}

#check ((λ (f : set (set α)), ⋂₀ f) ''
       {f : set (set α) | f.finite ∧ f ⊆ {s : set α | ∃ (a : α), s = (Ici a)ᶜ} ∧ (⋂₀ f).nonempty})

#check is_topological_basis_of_subbasis t.topology_eq_generate_Ici_comp


#check set.sInter

#check compl_Union
#check compl_sUnion

#check upper_set.Union_Ici

#check Inter_exists


#check sInter
#check Inter

variable (F : set α)



#check  ⋂ (a : α) (H: a ∈ F), (Ici a)ᶜ

#check  set.Inter (λ (a : α) , Ici a)

variable f:α → set β

#check Inter f

#check f '' F

#check symm

lemma testi : (⋂ (x : α) (H : x ∈ F), f x) = sInter (f '' F) :=
begin
  rw sInter_image,
end

lemma testt (a b : α) : a = b → f a = f b :=
begin
  exact congr_arg (λ (a : α), f a),
end

lemma teste (a b : α) : a = b ↔ b=a :=
begin
exact comm
end

lemma  test4 (F: set α) : (⋃ (a : α) (H : a ∈ F), Ici a)ᶜ = ⋂ (a : α) (H : a ∈ F), (Ici a)ᶜ :=
begin
rw upper_set.Union_Ici,
rw upper_set.Inter_Ici,
end

lemma finite_inter : {s : set α | ∃ (F : set α),  F.finite ∧ s = (upper_closure F : set α)ᶜ ∧ ((upper_closure F : set α)ᶜ.nonempty) } =
  ((λ (f : set (set α)), ⋂₀ f) ''
       {f : set (set α) | f.finite ∧ f ⊆ {s : set α | ∃ (a : α), s = (Ici a)ᶜ} ∧ (⋂₀ f).nonempty}) :=
begin
  rw image,
  ext,
  rw mem_set_of_eq,
  rw mem_set_of_eq,
  split,
  { intro h,
    cases h with F,
    let f := {s : set α | ∃ a ∈ F,  (Ici a)ᶜ = s},
    have ef: ⋂₀f = ⋂₀{s : set α | ∃ a ∈ F, (Ici a)ᶜ = s} := by refl,
    have efn: (⋂₀ f) = (upper_closure F : set α)ᶜ :=
    begin
      rw ← upper_set.Inter_Ici,
      rw ← sInter_image,
      rw ef,
      apply congr_arg,
      rw image,
      simp_rw [exists_prop],
    end,
    use f,
    rw mem_set_of_eq,
    split,
    { split,
      { sorry, },
      { split,
        { simp only [set_of_subset_set_of, forall_exists_index, forall_apply_eq_imp_iff₂, compl_inj_iff, exists_apply_eq_apply', implies_true_iff],  },
        { rw efn, exact h_h.2.2 } },
    },
    { rw [h_h.2.1,  ← upper_set.Inter_Ici, sInter_eq_bInter],
      simp only [mem_set_of_eq, exists_prop, Inter_exists, bInter_and', Inter_Inter_eq_left],
      sorry, }
   },
  { sorry, }

--simp only [coe_upper_closure, exists_prop, nonempty_sInter],
  --sorry,
end

include t


/-
lemma ltbasis' : is_topological_basis  {s | ∃(F : set α), F.finite ∧ s = ((upper_closure F) : set α)ᶜ } :=
begin
  rw finite_inter,
  apply is_topological_basis_of_subbasis t.topology_eq_generate_Ici_comp,
end
-/
lemma ltbasis : is_topological_basis  {s | ∃(F : set α), F.finite ∧ s = ((upper_closure F) : set α)ᶜ } :=
begin
  refine ⟨_, _, _⟩,
  { intros t₁ h₁ t₂ h₂ x hx,
    rw mem_set_of_eq at h₁ h₂,
    cases h₁ with F₁,
    cases h₂ with F₂,
    let t₃ := (upper_closure (F₁∪F₂) : set α)ᶜ,
    use t₃,
    split,
    { rw mem_set_of_eq, use F₁∪F₂,
      sorry, },
    { have et : t₃ = t₁ ∩ t₂ := by rw [h₁_h.2, h₂_h.2, pair_union],
      rw et,
      split,
      { exact hx,},
      { exact rfl.subset, }, },
     },
  { rw subset_antisymm_iff,
    split,
    { apply subset_univ, },
    { refine subset_sUnion_of_mem _,
      rw mem_set_of_eq,
      use ∅,
      rw univ_empty,
      sorry,
       } },
  { rw t.topology_eq_generate_Ici_comp,
    rw le_antisymm_iff,
    split,
    { sorry, },
    { apply generate_from_mono,
      rw set_of_subset_set_of,
      intros F h,
      cases h with a,
      use {a},
      rw [h_h, compl_inj_iff, ← upper_closure_singleton, upper_set.coe_Ici],
      sorry,
       } }
end




lemma is_open_iff_generate_Ici_comp {s : set α} :
  is_open s ↔ generate_open {s | ∃a, s = (Ici a)ᶜ} s :=
by rw [t.topology_eq_generate_Ici_comp]; refl

lemma lower_open_is_lower {s : set α} (h: is_open s) : is_lower_set s :=
begin
  rw is_open_iff_generate_Ici_comp at h,
  induction h,
  case topological_space.generate_open.basic : u
  { rw mem_set_of_eq at h_H,
    choose a h_H using h_H,
    rw h_H,
    apply ici_comp_is_lower a, },
  case topological_space.generate_open.univ : { exact is_lower_set_univ },
  case topological_space.generate_open.inter : u v hu1 hv1 hu2 hv2
    { apply is_lower_set.inter hu2 hv2 },
  case topological_space.generate_open.sUnion : { apply is_lower_set_sUnion h_ih, },
end

-- II 14th Dec 2001 Lawson = Fell
-- III 6th July 2002 Primitive nets
-- IV 15th Jan 2003 Deduce Fell

lemma ici_is_closed (b : α) : is_closed (Ici b)  :=
begin
  rw [← is_open_compl_iff, is_open_iff_generate_Ici_comp],
  fconstructor,
  rw mem_set_of_eq,
  use b,
end

lemma upper_closure_lower_closed (F : set α) (h : F.finite) : is_closed (upper_closure F : set α) :=
begin
  sorry,
  /-rw ← upper_set.Inter_Ici,
  apply is_closed_bUnion h,
  intros a h₁,
  apply ici_is_closed,-/
end

open classical

lemma singleton_closure (a : α) : closure {a} = Ici a :=
begin
  rw subset_antisymm_iff,
  split,
  { apply closure_minimal _ (ici_is_closed a), rw [singleton_subset_iff, mem_Ici], },
  { unfold closure,
    refine subset_sInter _,
    intro u,
    intro h,
    rw mem_set_of_eq at h,
    intro b,
    intro hb,
    rw mem_Ici at hb,
    rw singleton_subset_iff at h,
    rw ← is_open_compl_iff at h,
    by_contradiction H,
    rw ← mem_compl_iff at H,
    have h1: a ∈ uᶜ, from lower_open_is_lower h.left hb H,
    rw mem_compl_iff at h1,
    rw ← not_not_mem at h,
    apply absurd h1 h.right, },
end

@[priority 90] -- see Note [lower instance priority]
instance lower_topology.to_t0_space : t0_space α :=
begin
  rw t0_space_iff_inseparable,
  intros x y h,
  rw [inseparable_iff_closure_eq, singleton_closure, singleton_closure, subset_antisymm_iff] at h,
  rw le_antisymm_iff,
  split,
  { rw ← Ici_subset_Ici, apply h.2, },
  { rw ← Ici_subset_Ici, apply h.1, }
end



variables [topological_space β] [partial_order β] [s : lower_topology β]

include s

instance : lower_topology (α × β) :=
{ topology_eq_generate_Ici_comp :=
  begin
    rw le_antisymm_iff,
    split,
    { apply le_generate_from,
      intros,
      rw mem_set_of_eq at H,
      rcases H,
      cases H_w,
      rw H_h,
      rw [is_open_compl_iff, l1],
      apply is_closed.inter,
      { apply is_closed.prod is_closed_univ, apply ici_is_closed, },
      { apply is_closed.prod, apply ici_is_closed, apply is_closed_univ, } },
    { sorry }
  end }

end lower_topology

section prime

variables [has_inf α] [has_le α]

/--
An element `a` is said to be prime if whenever `a ≤ b ⊓ c` at least one of `a ≤ b`, `a ≤ c` holds.
-/
def is_prime (a : α) : Prop := ∀ b c, a ≤ b ⊓ c → a ≤ b ∨ a ≤ c

/-
The subtype of prime elements of a partial order with inf
-/
-- def prime (β : Type u) [has_inf β] [has_le β] := {a : β // is_prime a}

end prime
