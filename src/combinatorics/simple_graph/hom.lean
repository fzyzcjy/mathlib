/-
Copyright (c) 2022 Joanna Choules. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joanna Choules
-/
import topology.category.Top.limits
import combinatorics.simple_graph.subgraph

/-!
# Homomorphisms from finite subgraphs

This file defines the type of finite subgraphs of a `simple_graph` and proves a compactness result
for homomorphisms to a finite codomain.

## Main statements

* `simple_graph.exists_hom_of_all_finite_homs`: If every finite subgraph of a (possibly infinite)
  graph `G` has a homomorphism to some finite graph `F`, then there is also a homomorphism `G →g F`.

## Notations

`→fg` is a variant on `→g` where the domain is a finite subgraph of some supergraph `G`.

## Implementation notes

The proof here uses compactness as formulated in `nonempty_sections_of_fintype_inverse_system`. For
finite subgraphs `G'' ≤ G'`, the inverse system `fin_subgraph_hom_functor` restricts homomorphisms
`G' →fg F` to domain `G''`.
-/

universes u v
variables {V : Type u} {W : Type v} {G : simple_graph V} {F : simple_graph W}

/-- The subtype of `G.subgraph` comprising those subgraphs with finite vertex sets. -/
abbreviation simple_graph.fin_subgraph (G : simple_graph V) :=
{ G' : G.subgraph // G'.verts.finite }

/-- A graph homomorphism from a finite subgraph of G to F. -/
abbreviation fin_subgraph_hom (G' : G.fin_subgraph) (F : simple_graph W) := G'.val.coe →g F

local infix ` →fg ` : 50 := fin_subgraph_hom

/-- The finite subgraph of G generated by a single vertex. -/
def vertex_singleton (v : V) : G.fin_subgraph :=
 ⟨{verts := {v},
   adj := λ _ _, false,
   adj_sub := λ _ _, by contradiction,
   edge_vert := λ _ _, by contradiction},
  by simp only [set.finite_singleton]⟩

/-- The finite subgraph of G generated by a single edge. -/
def edge_singleton {u v : V} (e : G.adj u v) : G.fin_subgraph :=
  ⟨{verts := {u, v},
    adj := λ x y, (x = u ∧ y = v) ∨ (y = u ∧ x = v),
    adj_sub := λ x y, by {rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩), exact e, exact e.symm},
    edge_vert := λ x _, by {rintro (⟨rfl, _⟩ | ⟨_, rfl⟩); simp}},
  by simp only [set.finite.insert, set.finite_singleton]⟩

/- Lemmas establishing the ordering between edge- and vertex-generated subgraphs. -/

lemma vertex_left_le_edge {u v : V} {e : G.adj u v} : vertex_singleton u ≤ edge_singleton e :=
begin
  split,
  { unfold vertex_singleton, unfold edge_singleton,
    simp only [subtype.coe_mk, set.singleton_subset_iff, set.mem_insert_iff, eq_self_iff_true,
               true_or]},
  { unfold vertex_singleton,
    simp only [subtype.coe_mk, is_empty.forall_iff, forall_2_true_iff]},
end

lemma vertex_right_le_edge {u v : V} {e : G.adj u v} : vertex_singleton v ≤ edge_singleton e :=
begin
  split,
  { unfold vertex_singleton, unfold edge_singleton,
    simp only [subtype.coe_mk, set.singleton_subset_iff, set.mem_insert_iff, set.mem_singleton,
               or_true]},
  { unfold vertex_singleton,
    simp only [subtype.coe_mk, is_empty.forall_iff, forall_2_true_iff]}
end

/-- Given a homomorphism from a subgraph to `F`, construct its restriction to a sub-subgraph. -/
def fin_subgraph_hom_restrict {G' G'' : G.fin_subgraph} (h : G'' ≤ G') (f : G' →fg F) : G'' →fg F :=
begin
  refine ⟨λ ⟨v, hv⟩, f.to_fun ⟨v, h.1 hv⟩, _⟩,
  rintros ⟨u, hu⟩ ⟨v, hv⟩ huv,
  exact f.map_rel' (h.2 huv),
end

/-- The inverse system of finite homomorphisms. -/
def fin_subgraph_hom_functor (G : simple_graph V) (F : simple_graph W) :
  (G.fin_subgraph)ᵒᵖ ⥤ Type (max u v) :=
{ obj := λ G', G'.unop →fg F,
  map := λ G' G'' g f, fin_subgraph_hom_restrict (category_theory.le_of_hom g.unop) f, }

/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is
a homomorphism from the whole of `G` to `F`. -/
lemma simple_graph.exists_hom_of_all_finite_homs [finite W]
  (h : Π (G' : G.fin_subgraph), G' →fg F) : nonempty (G →g F) :=
begin
  /- Obtain a `fintype` instance for `W`. -/
  casesI nonempty_fintype W,
  /- Establish the required interface instances. -/
  haveI : is_directed G.fin_subgraph (≤) :=
    ⟨λ i j : G.fin_subgraph, ⟨⟨simple_graph.subgraph.union ↑i ↑j,
                              set.finite.union i.property j.property⟩,
                              by { simp_rw [← subtype.coe_le_coe, subtype.coe_mk],
                                   exact ⟨le_sup_left, le_sup_right⟩ }⟩⟩,
  haveI : ∀ (G' : (G.fin_subgraph)ᵒᵖ), nonempty ((fin_subgraph_hom_functor G F).obj G') :=
    λ G', ⟨h G'.unop⟩,
  haveI : Π (G' : (G.fin_subgraph)ᵒᵖ), fintype ((fin_subgraph_hom_functor G F).obj G') :=
  begin
    intro G',
    haveI : fintype (↥(G'.unop.val.verts)) := G'.unop.property.fintype,
    haveI : fintype (↥(G'.unop.val.verts) → W) := begin
      classical,
      exact pi.fintype
    end,
    exact fintype.of_injective (λ f, f.to_fun) rel_hom.coe_fn_injective
  end,
  /- Use compactness to obtain a section. -/
  obtain ⟨u, hu⟩ := nonempty_sections_of_fintype_inverse_system (fin_subgraph_hom_functor G F),
  refine ⟨⟨λ v, _, _⟩⟩,
  /- Map each vertex using the homomorphism provided for its singleton subgraph. -/
  exact (u (opposite.op (vertex_singleton v))).to_fun
    ⟨v, by {unfold vertex_singleton, simp only [opposite.unop_op, set.mem_singleton]}⟩,
  /- Prove that the above mapping preserves adjacency. -/
  intros v v' e,
  /- The homomorphism for each edge's singleton subgraph agrees with those for its source and target
  vertices. -/
  have hv : opposite.op (edge_singleton e) ⟶ opposite.op (vertex_singleton v) :=
    quiver.hom.op (category_theory.hom_of_le vertex_left_le_edge),
  have hv' : opposite.op (edge_singleton e) ⟶ opposite.op (vertex_singleton v') :=
    quiver.hom.op (category_theory.hom_of_le vertex_right_le_edge),
  rw [← (hu hv), ← (hu hv')],
  apply simple_graph.hom.map_adj,
  /- `v` and `v'` are definitionally adjacent in `edge_singleton e` -/
  exact or.inl ⟨rfl, rfl⟩,
end
